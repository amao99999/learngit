package com.amao.Ademo_KP;

/*
    知识点
 */
public class KnowledgePoint {
    /*
        final关键字的概述:final是一个关键字,表示不可变的意思,可以用来修饰类,方法,变量
            final关键字的使用:
                修饰类:
                        格式: public final class 类名{}
                        特点: 被final修饰的类不能被继承
                修饰方法:
                        格式: 修饰符 final 返回值类型 方法名(形参列表){}
                        特点:被final修饰的方法不能被重写
                修饰变量
                        修饰局部变量:
                                   基本类型局部变量:
                                                 格式 final 数据类型 变量名=值;

                                   引用类型局部变量:
                                                 格式: final 类名 对象名=new 类名();
                                                 特点:final修饰的对象的属性值可以修改
                        修饰成员变量:
                                   直接赋值: final 数据类型 变量名=值
                                   构造方法方式: 必须保证所有构造方法都可以给这个final修饰的变量赋值,并且只赋值一次

                        特点:1.被final修饰的变量只能赋值一次.不能重复赋值
                            2.被final修饰的变量就会变成常量,常量的书写规范是所有字母大写

                 有什么用:

          ------------------------------------------------------------------------------------------
            static关键字概述:static是一个关键字,表示静态的意思,可以用来修饰成员变量,成员方法,代码块
            static关键字的作用:
                修饰成员变量:
                        格式: static 数据类型 变量名;
                        特点: 被static修饰的成员变量会变成静态变量(类变量),该静态变量的值会被该类的所有对象共享,也就是说该类的
                            所有对象使用的是同一个变量值;
                        访问方式:
                                对象名.静态成员变量名
                                类名.静态成员变量名

            静态成员:
                    是随着类的加载而加载,并且只会加载一次
                    静态成员会被加载到静态区


               static修饰成员方法:
                    格式:修饰符 static 返回值类型 方法名(形参列表){}
                    特点:被static修饰的方法叫做静态成员方法
                    访问方式:
                            对象名.静态成员方法名(实参);
                            类名.静态成员方法名(实参);  推荐
                    注意事项:
                            1.静态方法父子类中出现一模一样的静态方法,不叫作方法重写
                            2.静态方法中不能出现this关键字(因为静态方法可以通过类名调用了,所以this就不知道代表哪个对象)
                            3.静态方法中不能直接访问非静态成员变量和成员方法
                            4.静态方法中只能直接访问静态成员变量和静态成员方法
                            5.非静态方法中可以访问一切成员(静态,非静态)




            static修饰代码块:
                格式:
                    static {}
                位置:定义在类中方法外
                执行:随着类的加载而执行,并且只执行一次
                特点:
                    1.优先于构造方法执行
                    2.main方法所在的类如果有静态代码块,那么该静态代码块优先于main方法的执行


            static应用:
                以后开发中static应用:
                    1.开发中,程序需要使用固定的数据那么就可以使用 static + final 来定义 一般public static final同时出现
                    2.开发中,程序需要使用的通用功能,就可以定义成静态成员方法
------------------------------------------------------------------------------------------------------------
       接口:
            接口的概述:接口是java语言中的一种引用类型,是方法的"集合",所有接口的内部主要就是定义方法
            接口是java语言中的一种引用类型
            接口中主要用来定义方法
                jdk7以前:    只能定义常量和抽象方法
                jdk8:       额外增加了默认方法和静态方法
                jdk9以上:    额外增加了私有方法

            定义接口:  interface关键字,编译之后也会产生class文件
            接口不能创建对象,需要实现接口(implements),实现接口的类叫做实现类(接口的子类)
                实现类:普通类,必须重写接口中的抽象方法
                实现类:抽象类,可以不用重写接口中的抽象方法

            实现接口:
                实现的概述:
                    类和接口的关系就是实现关系,实现接口的类就叫做实现类(接口的子类),一个类实现一个接口需要使用
                    implements关键字

                实现格式:
                    单实现:
                         public class 类名 implements 接口名{}0
                    多实现
0                         一个类同时实现多个接口
                         public class 类名 implements 接口名1,接口名2,接口3,...{}

            接口中成员的访问特点:
                接口中常量:          使用接口名直接访问   IA.NUM 主要供接口直接使用(访问)(推荐),也可以通过实现类对象直接访问(不推荐)
                接口中抽象方法:       用来强制实现类重写的,实现类对象调用重写的方法,如果实现类是抽象类可以不重写
                接口中默认方法:       主要供实现类对象直接调用,或者实现类重写,不能用接口来调用,通过实现类对象调用接口中的默认方法
                接口中静态方法:       只能供接口直接调用,实现类对象不能调用接口中的静态方法,只能用接口中.静态方法,接口名直接访问
                接口中的私有方法:     只能在接口中访问,

                多实现时的几种冲突情况(同名):
                公有静态常量的冲突:  实现类不会继承,也就不能访问这个冲突的常量
                公有抽象方法的冲突   实现类必须重写一次
                公有默认方法的冲突   实现类必须重写一次
                公有静态方法的冲突   不存在冲突
                私有方法的冲突      不存在冲突


                接口和接口的关系: 继承关系
                单继承:一个接口继承另一个接口
                      public interface 子接口名 extends 父接口{}
                多继承:一个接口同时继承多个接口
                      public interface 子接口名 extends 父接口1,父接口名2,...{}
                多层继承:A接口继承B接口,B接口继承C接口
                      public interface A extends B{}
                      public interface B extends C{}


            接口多继承几种冲突情况
                常量:        多个父接口有相同的常量,子接口无法继承,也无法使用
                抽象方法:     多个父接口中有相同的抽象方法,子接口只会继承一个抽象方法
                默认方法:     多个父接口中有相同的默认方法,子接口必须重写一次,而且重写的方法要加default
                静态方法:     多个父接口中有相同的静态方法,子接口不需要重写,因为静态方法是直接属于某个接口的,不能被继承
                私有方法      多个父接口中有相同的私有方法,子接口不需要重写,因为私有方法只能在本类中使用
                       对比:
                            实现类重写接口中的默认方法,不需要加default
                            接口重写父接口中的默认方法,需要加default


            类可以继承的同时又实现接口 (必须先继承,再实现接口)
                    格式: public class 类名 extends 父类名 implements 接口1,接口2...{}
            实现类继承父类又实现接口时的冲突
                常量:         父类和父接口中有相同的常量,那么子类(实现类)无法使用
                抽象方法       父类和父接口中有相同的抽象方法,那么子类(实现类)可以继承,必须重写一次
                默认方法       父类和父接口中有相同的默认方法,那么子类优先使用父类的
                静态方法       父类和父接口中有相同的静态方法,那么子类使用的是父类的,因为父类的静态方法可以继承,而父接口中的静态方法不可以继承
                私有方法       父类和父接口中有相同的私有方法,没有影响

         额外的功能 --->在接口中定义,让实现类实现
            如果可以确定的通用功能,使用默认方法
            如果不能确定的功能,使用抽象方法
        共性的功能---->在父类中定义,在子类继承
            如果可以确定的通用功能,使用默认方法
            如果不能确定的功能,使用抽象方法
         */


}
